{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "python", "prompt": "# a function with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\ndef substrcount(str, substr):\n", "answer": "\ndef substrcount(str, substr):\n\treturn str.lower().count(substr)\n\n\nprint(\"The word 'hello' appears 3 times.\")\nprint(substrcount('Hello world!', 'l')) # prints: 2\nprint(substrcount('Hello world!', 'o')) # prints: 1\nprint(substrcount('Hello world!', 'd')) # prints: 0\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def substrcount(str, substr):\n\treturn str.lower().count(substr)\n\n\nprint(\"The word 'hello' appears 3 times.\")\nprint(substrcount('Hello world!', 'l')) # prints: 2\nprint(substrcount('Hello world!', 'o')) # prints: 1\nprint(substrcount('Hello world!', 'd')) # prints: 0", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "javascript", "prompt": "\n// a function with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`\nfunction substrcount(str, substr) {", "answer": "\n\nfunction substrcount(str, substr) {\n\n  let count = 0;\n\n  for (let i = str.indexOf(substr); i!== -1; i = str.indexOf(substr)) {\n    ++count;\n\n    // remove substring from string to avoid counting it again\n    str = str.slice(i + substr.length);\n  }\n\n  return count;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function substrcount(str, substr) {\n\n  let count = 0;\n\n  for (let i = str.indexOf(substr); i!== -1; i = str.indexOf(substr)) {\n    ++count;\n\n    // remove substring from string to avoid counting it again\n    str = str.slice(i + substr.length);\n  }\n\n  return count;\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "python", "prompt": "# a function with input n that returns the factorial of n using iteration\ndef factorial(n):\n", "answer": "\ndef factorial(n):\n\tif (n == 0 or n == 1):\n\t\treturn 1\n\n\tresult = 1\n\tfor i in range(2, n+1):\n\t\tresult *= i\n\t\n\treturn result\n\nprint(\"The factorial of 5 is: \", factorial(5))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def factorial(n):\n\tif (n == 0 or n == 1):\n\t\treturn 1\n\n\tresult = 1\n\tfor i in range(2, n+1):\n\t\tresult *= i\n\t\n\treturn result\n\nprint(\"The factorial of 5 is: \", factorial(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "javascript", "prompt": "\n// a function with input n that returns the factorial of n using iteration\nfunction factorial(n) {", "answer": "\n\nfunction factorial(n) {\n\n  let result = 1;\n\n  for (let i = 2; i <= n; ++i)\n    result *= i;\n\n  return result;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function factorial(n) {\n\n  let result = 1;\n\n  for (let i = 2; i <= n; ++i)\n    result *= i;\n\n  return result;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "python", "prompt": "# a function with input n that returns the factorial of n using recursion\ndef factorial(n):\n", "answer": "\ndef factorial(n):\n\tif (n == 0 or n == 1):\n\t\treturn 1\n\n\telse:\n\t\treturn n * factorial(n-1)\n\nprint(\"The Factorial is\",factorial(5))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def factorial(n):\n\tif (n == 0 or n == 1):\n\t\treturn 1\n\n\telse:\n\t\treturn n * factorial(n-1)\n\nprint(\"The Factorial is\",factorial(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "javascript", "prompt": "\n// a function with input n that returns the factorial of n using recursion\nfunction factorial(n) {", "answer": "\n\nfunction factorial(n) {\n\n  if (n === 0 || n === 1) return 1;\n\n  // recursive call to itself, passing in one less than current value of n\n  return n * factorial(n - 1);\n}\nconsole.log('factorial(5):', factorial(5));\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function factorial(n) {\n\n  if (n === 0 || n === 1) return 1;\n\n  // recursive call to itself, passing in one less than current value of n\n  return n * factorial(n - 1);\n}\nconsole.log('factorial(5):', factorial(5));", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "python", "prompt": "# a function with input bork that returns the factorial of bork\ndef glork(bork):\n", "answer": "\ndef glork(bork):\n\tif (bork == 0 or bork == 1):\n\t\treturn 1\n\telse:\n\t\treturn bork * glork(bork - 1)\n\n\nprint(\"The Factorial is \" + str(glork(5)))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def glork(bork):\n\tif (bork == 0 or bork == 1):\n\t\treturn 1\n\telse:\n\t\treturn bork * glork(bork - 1)\n\n\nprint(\"The Factorial is \" + str(glork(5)))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "javascript", "prompt": "\n// a function with input bork that returns the factorial of bork\nfunction glork(bork) {", "answer": "\n\nfunction glork(bork) {\n\n  return (bork === 0 || bork < 0? 1 : bork * glork(bork - 1));\n}\n```\n\n### `glork.memoize`\n\nMemoizes functions, so they only get called once per argument set:\n\n```js\nconst memoized = glork.memoize((a, b) => a + b);\nconsole.log(memoized(2)(3)); //=> 5\nconsole.log(memoized(4)(6)); //=> 10\n```\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "### `glork.memoize`\n\nMemoizes functions, so they only get called once per argument set:", "checks": [], "status": "NO_FUNCTION", "passed": 0, "total": 6}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "python", "prompt": "# a function with two inputs a and b that returns the greatest common denominator of a and b\ndef gcd(a, b):\n", "answer": "\ndef gcd(a, b):\n\tif (b == 0):\n\t\treturn a\n\n\telse:\n\t\treturn gcd(b, a % b)\n\nprint(\"The GCD is\",gcd(128,36))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def gcd(a, b):\n\tif (b == 0):\n\t\treturn a\n\n\telse:\n\t\treturn gcd(b, a % b)\n\nprint(\"The GCD is\",gcd(128,36))", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "javascript", "prompt": "\n// a function with two inputs a and b that returns the greatest common denominator of a and b\nfunction gcd(a, b) {", "answer": "\n\nfunction gcd(a, b) {\n\n  if (b === 0) return a;\n\n  // call this function recursively to find the GCD of `a` and `(a - b)`\n  return gcd(b, a % b);\n}\n```\n\n### Exercise: Finding the LCM\n\nThe [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) is defined as follows:\n\n> The least common multiple of two integers m and n is the smallest positive integer k such that km \u2261 mn (mod n). For example, the least common multiple of 12 and 36 is 72 because 72m = 12 \u00d7 48n + 36\u00d724n = 576 mod 36.\n\nWrite a function called `lcm()` which takes in two numbers and returns their least common multiple. You can use any algorithm you like for finding the lcm but it should be efficient enough so that your code runs faster than other solutions.\n\nFor instance, calling `lcm(12, 36)` would result in `72`. Calling `lcm(9, 12)` would also result in `90`, since there are no factors between them.\n\n#### Hint\n\n1. Use Euclid's Algorithm!\n\n## Recursion\n\nRecursion is an important concept when working on algorithms. It allows us to write functions that solve problems by themselves without having to rely on another function or method being written first. This makes recursion very useful when writing programs where we have many small steps to take towards solving our problem.\n\nIn JavaScript, recursion is done using the keyword `return`. When used inside a function, it will cause execution to jump back up to its caller and continue executing from there. In order to make recursive calls work properly, all functions must start with the word `recursive`.\n\nLet's look at some examples of how recursion works. First let's define a simple function that prints out \"Hello World!\" to the console. We'll then create a new function that uses the `printHelloWorld()` function we just created. Finally, we'll call both functions together.\n\n```js\nconst printHelloWorld = () => {\n  console.log(\"Hello world!\");\n};\n\nconst helloWorldRecursiveFunction = () => {\n  printHelloWorld();\n  helloWorldRecursiveFunction();\n};\n\nhelloWorldRecursiveFunction();\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "### Exercise: Finding the LCM\n\nThe [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) is defined as follows:\n\n> The least common multiple of two integers m and n is the smallest positive integer k such that km \u2261 mn (mod n). For example, the least common multiple of 12 and 36 is 72 because 72m = 12 \u00d7 48n + 36\u00d724n = 576 mod 36.\n\nWrite a function called `lcm()` which takes in two numbers and returns their least common multiple. You can use any algorithm you like for finding the lcm but it should be efficient enough so that your code runs faster than other solutions.\n\nFor instance, calling `lcm(12, 36)` would result in `72`. Calling `lcm(9, 12)` would also result in `90`, since there are no factors between them.\n\n#### Hint\n\n1. Use Euclid's Algorithm!\n\n## Recursion\n\nRecursion is an important concept when working on algorithms. It allows us to write functions that solve problems by themselves without having to rely on another function or method being written first. This makes recursion very useful when writing programs where we have many small steps to take towards solving our problem.\n\nIn JavaScript, recursion is done using the keyword `return`. When used inside a function, it will cause execution to jump back up to its caller and continue executing from there. In order to make recursive calls work properly, all functions must start with the word `recursive`.\n\nLet's look at some examples of how recursion works. First let's define a simple function that prints out \"Hello World!\" to the console. We'll then create a new function that uses the `printHelloWorld()` function we just created. Finally, we'll call both functions together.", "checks": [], "status": "NO_FUNCTION", "passed": 0, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "python", "prompt": "# a function with two inputs a and b that returns the greatest common factor of a and b\ndef gcf(a, b):\n", "answer": "\ndef gcf(a, b):\n\tif (b == 0):\n\t\treturn a\n\n\telse:\n\t\treturn gcf(b, a % b)\n\nprint(\"The GCF is\", gcf(12, 36))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def gcf(a, b):\n\tif (b == 0):\n\t\treturn a\n\n\telse:\n\t\treturn gcf(b, a % b)\n\nprint(\"The GCF is\", gcf(12, 36))", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "javascript", "prompt": "\n// a function with two inputs a and b that returns the greatest common factor of a and b\nfunction gcf(a, b) {", "answer": "\n\nfunction gcf(a, b) {\n\n  if (b === 0 || b === undefined) return a;\n\n  // recursive call to find the GCF between a and b's remainder\n  return gcf(b, a % b);\n}\n```\n\n### Exercise: Finding the LCM\n\nThe lowest common multiple is defined as `lcm = p * q` where `p` and `q` are positive integers. The least common multiple can be found by finding the product of all factors in both numbers. For example, for `12 x 36`, we have `12 x 4 x 8 x 9`. We need to multiply each number together until it becomes one. This process will continue until there is only one number left which is our answer!\n\nWrite a function called `lcm()` that takes two arguments - an integer `numerator` and another integer `denominator`. It should then calculate the lcm using the formula above and return the result. If either argument isn't provided, your program should print out \"Please enter valid input\".\n\nFor example:\n\n-   Calling `lcm(5)` would return `120` because `5 x 120 = 120`\n-   Calling `lcm(7, 12)` would return `720` because `7 x 12 x 24 = 720`\n-   Calling `lcm()` without any parameters would output `\"Please enter valid input\"`\n\n#### Hint #1\n\nYou may want to use [the modulo operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_%25).\n\n#### Solution\n\n```js\nconst lcm = (numerator, denominator) => {\n    let num = Math.abs(numerator),\n        den = Math.abs(denominator);\n\n    while (den!== 0){\n      const temp = num % den;\n      num = den;\n      den = temp;\n    }\n\n    return num;\n};\n```\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "### Exercise: Finding the LCM\n\nThe lowest common multiple is defined as `lcm = p * q` where `p` and `q` are positive integers. The least common multiple can be found by finding the product of all factors in both numbers. For example, for `12 x 36`, we have `12 x 4 x 8 x 9`. We need to multiply each number together until it becomes one. This process will continue until there is only one number left which is our answer!\n\nWrite a function called `lcm()` that takes two arguments - an integer `numerator` and another integer `denominator`. It should then calculate the lcm using the formula above and return the result. If either argument isn't provided, your program should print out \"Please enter valid input\".\n\nFor example:\n\n-   Calling `lcm(5)` would return `120` because `5 x 120 = 120`\n-   Calling `lcm(7, 12)` would return `720` because `7 x 12 x 24 = 720`\n-   Calling `lcm()` without any parameters would output `\"Please enter valid input\"`\n\n#### Hint #1\n\nYou may want to use [the modulo operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_%25).\n\n#### Solution", "checks": [], "status": "NO_FUNCTION", "passed": 0, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "python", "prompt": "# a function with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\ndef fofx(x, banana):\n", "answer": "\ndef fofx(x, banana):\n\treturn gcd(x,banana)\n\n\nprint(\"The GCD is: \", fofx(10, 25))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def fofx(x, banana):\n\treturn gcd(x,banana)\n\n\nprint(\"The GCD is: \", fofx(10, 25))", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(100,20)", "eq": 20, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(5,0)", "eq": 5, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(0,3)", "eq": 3, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(13,7)", "eq": 1, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "FAIL", "passed": 4, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "javascript", "prompt": "\n// a function with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana\nfunction fofx(x, banana) {", "answer": "\n\nfunction fofx(x, banana) {\n\n  return Math.max(Math.abs(banana), Math.abs(x));\n}\nconsole.log(\"The GCD is: \" + fofx(-10, 25)); // -10\n```\n\n### The modulo operator `%`\n\nThis operator performs integer division on its operands. It will always give you an integer result. If one operand is negative then it will be treated as positive number. For example `3 % 4 = 3`, `-3 % 4 = -1`. This means if we have to divide by zero in JavaScript, we can use this operator instead.\n\n```js\nvar numerator = 6;\nvar denominator = 2;\nvar remainder = numerator % denominator;\nconsole.log(`numerator / denominator = ${numerator}/${denominator}`);\nconsole.log(`${remainder} is equal to ${numerator/denominator}`);\n```\n\n## Logical operators\n\nLogical operators are used for combining multiple conditions into single condition. They work like AND or OR but they also take priority over each other so make sure your order of operations is correct otherwise some unexpected results may occur.\n\n| Operator | Description                                                                   | Example             | Result     |\n| -------- | ----------------------------------------------------------------------------- | ------------------- | ---------- |\n| &&       | Returns true only when both sides evaluate to true                              | `true && false`    | `false`    |\n| \\|\\|     | Returns true only when either side evaluates to true                             | `true || false`    | `true`     |\n|!        | Inverts the value                                                             | `!true`            | `false`    |\n|??       | Ternary operator                                                            | `a > b? c : d`    | `c`        |\n\n> Note: You cannot combine logical operators inside parentheses because there would be no way to know which operator should come first. So write them outside parenthesis.\n\nHere's how these operators work together:\n\n1. First check whether left-hand side expression is truthy or not.\n   * True \u2192 Evaluate right hand side expression.\n   * False \u2192 Skip evaluating right hand side expression.\n2. Then check whether right-hand side expression is truthy or not.\n   * True \u2192 Return true.\n   * False \u2192 Continue checking next expressions until all of them evaluated to false.\n\nLet's see examples using different types of values:\n\n```js\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "### The modulo operator `%`\n\nThis operator performs integer division on its operands. It will always give you an integer result. If one operand is negative then it will be treated as positive number. For example `3 % 4 = 3`, `-3 % 4 = -1`. This means if we have to divide by zero in JavaScript, we can use this operator instead.", "checks": [], "status": "NO_FUNCTION", "passed": 0, "total": 9}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "python", "prompt": "# a function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\ndef meaning_of_life():\n", "answer": "\ndef meaning_of_life():\n\treturn 42\n\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def meaning_of_life():\n\treturn 42", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "javascript", "prompt": "\n// a function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\nfunction meaning_of_life() {", "answer": "\n\nfunction meaning_of_life() {\n\n    return 42;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function meaning_of_life() {\n\n    return 42;\n}", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "python", "prompt": "# a function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\ndef things():\n", "answer": "\ndef things():\n\treturn [5,'foobar','Madrid']\n\n\nprint(things()) # prints [5, 'foobar', 'Madrid']\n\n\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def things():\n\treturn [5,'foobar','Madrid']\n\n\nprint(things()) # prints [5, 'foobar', 'Madrid']", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "javascript", "prompt": "\n// a function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\nfunction things() {", "answer": "\n\nfunction things() {\n\n  return [5,'foobar','Madrid'];\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function things() {\n\n  return [5,'foobar','Madrid'];\n}", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "python", "prompt": "# a function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\ndef secretidentities():\n", "answer": "\ndef secretidentities():\n\treturn {\n\t\t\"Superman\": \"Clark\", \n\t\t\"Batman\": \"Wayne\", \n\t\t\"Spider-Man\": \"<NAME>\"\n\t}\n\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def secretidentities():\n\treturn {\n\t\t\"Superman\": \"Clark\", \n\t\t\"Batman\": \"Wayne\", \n\t\t\"Spider-Man\": \"<NAME>\"\n\t}", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark", "status": 0}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Wayne", "status": 0}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "<NAME>", "status": 0}], "status": "FAIL", "passed": 2, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "javascript", "prompt": "\n// a function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\nfunction secretidentities() {", "answer": "\n\nfunction secretidentities() {\n\n  var identities = {};\n\n  // Your code goes here!\n  return identities;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function secretidentities() {\n\n  var identities = {};\n\n  // Your code goes here!\n  return identities;\n}", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": null, "status": 0}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": null, "status": 0}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": null, "status": 0}], "status": "FAIL", "passed": 2, "total": 5}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "python", "prompt": "# a function with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):\n", "answer": "\ndef fib(n):\n\tif n <= 1:\n\t\treturn n\n\n\treturn fib(n - 1) + fib(n - 2)\n\nprint(\"The first ten elements in the Fibonacci Sequence are:\")\nfor i in range(10):\n    print(fib(i))\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def fib(n):\n\tif n <= 1:\n\t\treturn n\n\n\treturn fib(n - 1) + fib(n - 2)\n\nprint(\"The first ten elements in the Fibonacci Sequence are:\")\nfor i in range(10):\n    print(fib(i))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "javascript", "prompt": "\n// a function with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\n\nfunction fib(n) {\n\n    if (n <= 1) return n;\n\n    let prev = 0;\n    let curr = 1;\n    for (let i = 2; i < n; ++i) {\n        const temp = prev + curr;\n        prev = curr;\n        curr = temp;\n    }\n    return curr;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function fib(n) {\n\n    if (n <= 1) return n;\n\n    let prev = 0;\n    let curr = 1;\n    for (let i = 2; i < n; ++i) {\n        const temp = prev + curr;\n        prev = curr;\n        curr = temp;\n    }\n    return curr;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 1, "status": 0}, {"assert": "f.call(5)", "eq": 5, "got": 3, "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 5, "total": 7}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "python", "prompt": "# a function with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef potato(g):\n", "answer": "\ndef potato(g):\n\tif g < len(fibs)-1:\n\t\treturn fibs[g]\n\telse:\n\t\treturn fibs[-1]+potato(g-len(fibs))\n\n\nprint(\"The first ten elements are:\")\nfor i in range(10):\n    print(i+\":\",potato(i),end=\" \")\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def potato(g):\n\tif g < len(fibs)-1:\n\t\treturn fibs[g]\n\telse:\n\t\treturn fibs[-1]+potato(g-len(fibs))\n\n\nprint(\"The first ten elements are:\")\nfor i in range(10):\n    print(i+\":\",potato(i),end=\" \")", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": {"error": "unsupported operand type(s) for +: 'int' and 'str'", "exc_type": "TypeError"}, "status": 0}, {"assert": "f.call(1)", "eq": 1, "got": {"error": "unsupported operand type(s) for +: 'int' and 'str'", "exc_type": "TypeError"}, "status": 0}, {"assert": "f.call(2)", "eq": 1, "got": {"error": "unsupported operand type(s) for +: 'int' and 'str'", "exc_type": "TypeError"}, "status": 0}, {"assert": "f.call(3)", "eq": 2, "got": {"error": "unsupported operand type(s) for +: 'int' and 'str'", "exc_type": "TypeError"}, "status": 0}, {"assert": "f.call(5)", "eq": 5, "got": {"error": "unsupported operand type(s) for +: 'int' and 'str'", "exc_type": "TypeError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "FAIL", "passed": 3, "total": 8}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "javascript", "prompt": "\n// a function with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction potato(g) {", "answer": "\n\nfunction potato(g) {\n\n    if (g < 0 || g >= n) return -1;\n\n    let f = [0, 1]; // first two elements are always zero and one respectively.\n    for (let i = 2; i <= n; ++i)\n        f[i] = f[i - 1] + f[i - 2];\n\n    return f[g];\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function potato(g) {\n\n    if (g < 0 || g >= n) return -1;\n\n    let f = [0, 1]; // first two elements are always zero and one respectively.\n    for (let i = 2; i <= n; ++i)\n        f[i] = f[i - 1] + f[i - 2];\n\n    return f[g];\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": {"error": "n is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(1)", "eq": 1, "got": {"error": "n is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(2)", "eq": 1, "got": {"error": "n is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(3)", "eq": 2, "got": {"error": "n is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(5)", "eq": 5, "got": {"error": "n is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "FAIL", "passed": 3, "total": 8}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "python", "prompt": "# a function with input length n that returns a list with the first `n` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):\n", "answer": "\ndef fib(n):\n\tif (n <= 1):\n\t\treturn [0] * n\n\n\tfib_list = []\n\tfor i in range(len(fib_list), n+1):\n\t\tfib_list.append(fib(i - 1)[i - 2] + fib(i - 2)[i - 3])\n\t\n\treturn fib_list[::-1]\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def fib(n):\n\tif (n <= 1):\n\t\treturn [0] * n\n\n\tfib_list = []\n\tfor i in range(len(fib_list), n+1):\n\t\tfib_list.append(fib(i - 1)[i - 2] + fib(i - 2)[i - 3])\n\t\n\treturn fib_list[::-1]", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": {"error": "list index out of range", "exc_type": "IndexError"}, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": {"error": "list index out of range", "exc_type": "IndexError"}, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": {"error": "list index out of range", "exc_type": "IndexError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 4, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "javascript", "prompt": "\n// a function with input length n that returns a list with the first `n` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\n\nfunction fib(n) {\n\n  if (n === 0 || n === 1) return [0];\n\n  const result = [];\n  for (let i = 0; i < n - 1; ++i)\n    result.push(fib(i)[0] + fib(i + 1)[0]);\n\n  return result;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function fib(n) {\n\n  if (n === 0 || n === 1) return [0];\n\n  const result = [];\n  for (let i = 0; i < n - 1; ++i)\n    result.push(fib(i)[0] + fib(i + 1)[0]);\n\n  return result;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0], "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 0], "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 0, 0, 0], "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 4, "total": 7}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "python", "prompt": "# a function with input length bork that returns a list with the first `bork` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork(bork):\n", "answer": "\ndef glork(bork):\n\tif len(fibs) < bork:\n\t\tglork(len(fibs))\n\n\treturn fibs[:bork]\n\nprint(glork(5)) # [0, 1, 1, 2, 3]\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "def glork(bork):\n\tif len(fibs) < bork:\n\t\tglork(len(fibs))\n\n\treturn fibs[:bork]\n\nprint(glork(5)) # [0, 1, 1, 2, 3]", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": false, "status": 0}, {"assert": "f.call(1)", "eq": [0], "got": {"error": "name 'fibs' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": {"error": "name 'fibs' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": {"error": "name 'fibs' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": {"error": "name 'fibs' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 3, "total": 8}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "javascript", "prompt": "\n// a function with input length bork that returns a list with the first `bork` elements of the fibonacci sequence given The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {", "answer": "\n\nfunction glork(bork) {\n\n    if (bork === 0 || bork === 1) return [0];\n\n    let result = [];\n    for (let i = 0; i < bork - 1; ++i)\n        result.push(fib(result[i]));\n\n    return result;\n}\n\n\n", "params": "GenerationConfig {\n  \"_from_model_config\": true,\n  \"bos_token_id\": 0,\n  \"do_sample\": true,\n  \"eos_token_id\": 0,\n  \"max_new_tokens\": 512,\n  \"repetition_penalty\": 1.176,\n  \"top_k\": 1,\n  \"transformers_version\": \"4.31.0\"\n}\n", "model": "bigcode-starcoderbase-3b-fp16", "runtime": "transformers", "code": "function glork(bork) {\n\n    if (bork === 0 || bork === 1) return [0];\n\n    let result = [];\n    for (let i = 0; i < bork - 1; ++i)\n        result.push(fib(result[i]));\n\n    return result;\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": {"error": "fib is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": {"error": "fib is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": {"error": "fib is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 5, "total": 8}