{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function factorial(n) with input n that returns the factorial of n using iteration<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef factorial(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer using iteration.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n, or 1 if n is 0.\n\n  Raises:\n    ValueError: If n is negative.\n  \"\"\"\n  if n < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif n == 0:\n    return 1\n  else:\n    fact = 1\n    for i in range(1, n + 1):\n      fact *= i\n    return fact\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def factorial(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer using iteration.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n, or 1 if n is 0.\n\n  Raises:\n    ValueError: If n is negative.\n  \"\"\"\n  if n < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif n == 0:\n    return 1\n  else:\n    fact = 1\n    for i in range(1, n + 1):\n      fact *= i\n    return fact\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function factorial(n) with input n that returns the factorial of n using iteration<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction factorial(n) {\n  if (n < 0) {\n    return \"Factorial is not defined for negative numbers\";\n  } else if (n === 0) {\n    return 1;\n  } else {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n      result *= i;\n    }\n    return result;\n  }\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function factorial(n) {\n  if (n < 0) {\n    return \"Factorial is not defined for negative numbers\";\n  } else if (n === 0) {\n    return 1;\n  } else {\n    let result = 1;\n    for (let i = 1; i <= n; i++) {\n      result *= i;\n    }\n    return result;\n  }\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function factorial(n) with input n that returns the factorial of n using recursion<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef factorial(n):\n  \"\"\"\n  This function calculates the factorial of a non-negative integer using recursion.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n, or 1 if n is 0.\n\n  Raises:\n    ValueError: If n is negative.\n  \"\"\"\n  if n < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif n == 0:\n    return 1\n  else:\n    return n * factorial(n - 1)\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def factorial(n):\n  \"\"\"\n  This function calculates the factorial of a non-negative integer using recursion.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The factorial of n, or 1 if n is 0.\n\n  Raises:\n    ValueError: If n is negative.\n  \"\"\"\n  if n < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif n == 0:\n    return 1\n  else:\n    return n * factorial(n - 1)\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function factorial(n) with input n that returns the factorial of n using recursion<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction factorial(n) {\n  // Base case: Factorial of 0 is 1\n  if (n === 0) {\n    return 1;\n  } else {\n    // Recursive case: n! = n * (n-1)!\n    return n * factorial(n - 1);\n  }\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function factorial(n) {\n  // Base case: Factorial of 0 is 1\n  if (n === 0) {\n    return 1;\n  } else {\n    // Recursive case: n! = n * (n-1)!\n    return n * factorial(n - 1);\n  }\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function glork(bork) with input bork that returns the factorial of bork<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef glork(bork):\n  \"\"\"\n  Calculates the factorial of a non-negative integer.\n\n  Args:\n    bork: The non-negative integer for which to calculate the factorial.\n\n  Returns:\n    The factorial of bork, or 1 if bork is 0.\n\n  Raises:\n    ValueError: If bork is negative.\n  \"\"\"\n  if bork < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif bork == 0:\n    return 1\n  else:\n    factorial = 1\n    for i in range(1, bork + 1):\n      factorial *= i\n    return factorial\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def glork(bork):\n  \"\"\"\n  Calculates the factorial of a non-negative integer.\n\n  Args:\n    bork: The non-negative integer for which to calculate the factorial.\n\n  Returns:\n    The factorial of bork, or 1 if bork is 0.\n\n  Raises:\n    ValueError: If bork is negative.\n  \"\"\"\n  if bork < 0:\n    raise ValueError(\"Factorial is not defined for negative numbers\")\n  elif bork == 0:\n    return 1\n  else:\n    factorial = 1\n    for i in range(1, bork + 1):\n      factorial *= i\n    return factorial\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function glork(bork) with input bork that returns the factorial of bork<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction glork(bork) {\n  // Handle cases where bork is not a positive integer\n  if (bork < 0 || !Number.isInteger(bork)) {\n    return \"Factorial is only defined for non-negative integers.\";\n  }\n\n  // Base case: factorial of 0 is 1\n  if (bork === 0) {\n    return 1;\n  }\n\n  // Recursive case: multiply bork by the factorial of (bork - 1)\n  return bork * glork(bork - 1);\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function glork(bork) {\n  // Handle cases where bork is not a positive integer\n  if (bork < 0 || !Number.isInteger(bork)) {\n    return \"Factorial is only defined for non-negative integers.\";\n  }\n\n  // Base case: factorial of 0 is 1\n  if (bork === 0) {\n    return 1;\n  }\n\n  // Recursive case: multiply bork by the factorial of (bork - 1)\n  return bork * glork(bork - 1);\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function gcd(a, b) with two inputs a and b that returns the greatest common denominator of a and b<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef gcd(a, b):\n  \"\"\"\n  Calculates the greatest common denominator (GCD) of two integers using Euclid's algorithm.\n\n  Args:\n    a: The first integer.\n    b: The second integer.\n\n  Returns:\n    The greatest common denominator of a and b.\n  \"\"\"\n  while b:\n    a, b = b, a % b\n  return a\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def gcd(a, b):\n  \"\"\"\n  Calculates the greatest common denominator (GCD) of two integers using Euclid's algorithm.\n\n  Args:\n    a: The first integer.\n    b: The second integer.\n\n  Returns:\n    The greatest common denominator of a and b.\n  \"\"\"\n  while b:\n    a, b = b, a % b\n  return a\n\n#", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common denominator of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function gcd(a, b) with two inputs a and b that returns the greatest common denominator of a and b<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction gcd(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function gcd(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcd", "got": "gcd", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function gcf(a, b) with two inputs a and b that returns the greatest common factor of a and b<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef gcf(a, b):\n  \"\"\"\n  Calculates the greatest common factor (GCF) of two integers a and b using Euclid's algorithm.\n\n  Args:\n    a: The first integer.\n    b: The second integer.\n\n  Returns:\n    The greatest common factor of a and b.\n  \"\"\"\n  while b:\n    a, b = b, a % b\n  return a\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def gcf(a, b):\n  \"\"\"\n  Calculates the greatest common factor (GCF) of two integers a and b using Euclid's algorithm.\n\n  Args:\n    a: The first integer.\n    b: The second integer.\n\n  Returns:\n    The greatest common factor of a and b.\n  \"\"\"\n  while b:\n    a, b = b, a % b\n  return a\n\n#", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "gcf(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common factor of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDAlternative", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function gcf(a, b) with two inputs a and b that returns the greatest common factor of a and b<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction gcf(a, b) {\n  // Handle cases where one or both inputs are zero\n  if (a === 0) return b;\n  if (b === 0) return a;\n\n  // Use Euclid's algorithm to find the GCF\n  while (b !== 0) {\n    let temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function gcf(a, b) {\n  // Handle cases where one or both inputs are zero\n  if (a === 0) return b;\n  if (b === 0) return a;\n\n  // Use Euclid's algorithm to find the GCF\n  while (b !== 0) {\n    let temp = b;\n    b = a % b;\n    a = temp;\n  }\n  return a;\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}, {"assert": "f.name", "eq": "gcf", "got": "gcf", "status": 1}], "status": "PASS", "passed": 9, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function fofx(x, banana) with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef gcd(x, banana):\n  \"\"\"\n  Calculates the greatest common denominator (GCD) of two integers.\n\n  Args:\n    x: The first integer.\n    banana: The second integer.\n\n  Returns:\n    The greatest common denominator of x and banana.\n  \"\"\"\n  while banana:\n    x, banana = banana, x % banana\n  return x\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def gcd(x, banana):\n  \"\"\"\n  Calculates the greatest common denominator (GCD) of two integers.\n\n  Args:\n    x: The first integer.\n    banana: The second integer.\n\n  Returns:\n    The greatest common denominator of x and banana.\n  \"\"\"\n  while banana:\n    x, banana = banana, x % banana\n  return x\n\n#", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "gcd", "status": 0}], "status": "FAIL", "passed": 8, "total": 9}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common denominator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function fofx(x, banana) with two inputs x and banana that returns the greatest common denominator (gcd) of x and banana<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction gcd(x, banana) {\n  // Handle cases where one or both inputs are zero\n  if (x === 0) return banana;\n  if (banana === 0) return x;\n\n  // Use Euclid's algorithm to find the GCD\n  while (banana !== 0) {\n    let temp = banana;\n    banana = x % banana;\n    x = temp;\n  }\n  return x;\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function gcd(x, banana) {\n  // Handle cases where one or both inputs are zero\n  if (x === 0) return banana;\n  if (banana === 0) return x;\n\n  // Use Euclid's algorithm to find the GCD\n  while (banana !== 0) {\n    let temp = banana;\n    banana = x % banana;\n    x = temp;\n  }\n  return x;\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,20)", "eq": 20, "got": 20, "status": 1}, {"assert": "f.call(5,0)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call(0,3)", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(13,7)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "gcd", "status": 0}], "status": "FAIL", "passed": 8, "total": 9}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function meaning_of_life() with no inputs that returns a single integer, the answer to life the universe and everything<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef meaning_of_life():\n  \"\"\"\n  This function returns the answer to life, the universe, and everything.\n\n  Returns:\n    int: The answer to life, the universe, and everything.\n  \"\"\"\n  return 42\n```\n\nThis function, when called, will return the integer `42`, the humorous answer to the ultimate question of life, the universe, and everything, as popularized by Douglas Adams's *The Hitchhiker's Guide to the Galaxy*. \n\n\nLet me know if you'd like to explore other fun Python functions!\n", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def meaning_of_life():\n  \"\"\"\n  This function returns the answer to life, the universe, and everything.\n\n  Returns:\n    int: The answer to life, the universe, and everything.\n  \"\"\"\n  return 42", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function meaning_of_life() with no inputs that returns a single integer, the answer to life the universe and everything<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction meaning_of_life() {\n  return 42;\n}\n```\n\nThis function, aptly named `meaning_of_life()`,  returns the integer `42`, a humorous reference to the science fiction comedy series *The Hitchhiker's Guide to the Galaxy* by Douglas Adams, where 42 is famously presented as the \"Answer to the Ultimate Question of Life, the Universe, and Everything\". \n\n\nLet me know if you'd like to explore other fun JavaScript functions!\n", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function meaning_of_life() {\n  return 42;\n}", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": 42, "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function things() with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef things():\n  return [5, 'foobar', 'Madrid']\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def things():\n  return [5, 'foobar', 'Madrid']", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "A simple list function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function things() with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction things() {\n  return [5, 'foobar', 'Madrid'];\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function things() {\n  return [5, 'foobar', 'Madrid'];\n}", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()[0]", "eq": 5, "got": 5, "status": 1}, {"assert": "f.call()[1]", "eq": "foobar", "got": "foobar", "status": 1}, {"assert": "f.call()[2]", "eq": "Madrid", "got": "Madrid", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function secretidentities() with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef secretidentities():\n  \"\"\"Returns a dictionary mapping superheroes to their real names.\"\"\"\n  return {\n      \"Superman\": \"Clark Kent\",\n      \"Batman\": \"Bruce Wayne\",\n      \"Spider-Man\": \"Peter Parker\"\n  }\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def secretidentities():\n  \"\"\"Returns a dictionary mapping superheroes to their real names.\"\"\"\n  return {\n      \"Superman\": \"Clark Kent\",\n      \"Batman\": \"Bruce Wayne\",\n      \"Spider-Man\": \"Peter Parker\"\n  }\n\n#", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "Peter Parker", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function secretidentities() with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction secretIdentities() {\n  return {\n    Superman: \"Clark Kent\",\n    Batman: \"Bruce Wayne\",\n    SpiderMan: \"Peter Parker\"\n  };\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function secretIdentities() {\n  return {\n    Superman: \"Clark Kent\",\n    Batman: \"Bruce Wayne\",\n    SpiderMan: \"Peter Parker\"\n  };\n}", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretIdentities", "status": 0}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq-any": ["Clark Kent", "Kal-El"], "got": "Clark Kent", "status": 1}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "Bruce Wayne", "status": 1}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": null, "status": 0}], "status": "FAIL", "passed": 3, "total": 5}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function fib(n) with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef fib(n):\n  \"\"\"\n  This function returns the nth element of the Fibonacci sequence.\n\n  Args:\n    n: The index of the desired Fibonacci number (0-based).\n\n  Returns:\n    The nth Fibonacci number.\n  \"\"\"\n  if n <= 0:\n    return 0\n  elif n == 1:\n    return 1\n  else:\n    return fib(n-1) + fib(n-2)\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def fib(n):\n  \"\"\"\n  This function returns the nth element of the Fibonacci sequence.\n\n  Args:\n    n: The index of the desired Fibonacci number (0-based).\n\n  Returns:\n    The nth Fibonacci number.\n  \"\"\"\n  if n <= 0:\n    return 0\n  elif n == 1:\n    return 1\n  else:\n    return fib(n-1) + fib(n-2)\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the `n`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation", "name": "FibonacciZeroShot", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function fib(n) with input element number n (0 based) that returns the `n`-th element of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction fib(n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}\n```\n\n**", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function fib(n) {\n  if (n <= 1) {\n    return n;\n  } else {\n    return fib(n - 1) + fib(n - 2);\n  }\n}", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function potato(g) with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef potato(g):\n  \"\"\"\n  Returns the g-th element of the Fibonacci sequence.\n\n  Args:\n    g: The index (0-based) of the desired Fibonacci number.\n\n  Returns:\n    The g-th Fibonacci number.\n  \"\"\"\n  if g < 0:\n    raise ValueError(\"Input must be a non-negative integer\")\n  elif g == 0:\n    return 0\n  elif g == 1:\n    return 1\n  else:\n    a = 0\n    b = 1\n    for _ in range(2, g + 1):\n      a, b = b, a + b\n    return b\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def potato(g):\n  \"\"\"\n  Returns the g-th element of the Fibonacci sequence.\n\n  Args:\n    g: The index (0-based) of the desired Fibonacci number.\n\n  Returns:\n    The g-th Fibonacci number.\n  \"\"\"\n  if g < 0:\n    raise ValueError(\"Input must be a non-negative integer\")\n  elif g == 0:\n    return 0\n  elif g == 1:\n    return 1\n  else:\n    a = 0\n    b = 1\n    for _ in range(2, g + 1):\n      a, b = b, a + b\n    return b\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "potato(g)", "Input": "with input element number g (0 based)", "Output": "the `g`-th element of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known relation if the name has been changed", "name": "FibonacciMisnamed", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function potato(g) with input element number g (0 based) that returns the `g`-th element of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction potato(g) {\n  if (g < 0) {\n    return \"Invalid input: g must be a non-negative integer\";\n  }\n  if (g === 0) {\n    return 0;\n  }\n  if (g === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i <= g; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function potato(g) {\n  if (g < 0) {\n    return \"Invalid input: g must be a non-negative integer\";\n  }\n  if (g === 0) {\n    return 0;\n  }\n  if (g === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 2; i <= g; i++) {\n    let temp = a + b;\n    a = b;\n    b = temp;\n  }\n  return b;\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}, {"assert": "f.args[0].name", "eq": "g", "got": "g", "status": 1}, {"assert": "f.name", "eq": "potato", "got": "potato", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function fib(n) with input length n that returns a list with the first `n` elements of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef fib(n):\n  \"\"\"\n  This function returns a list with the first n elements of the Fibonacci sequence.\n\n  Args:\n    n: The number of Fibonacci elements to generate.\n\n  Returns:\n    A list containing the first n Fibonacci numbers.\n  \"\"\"\n  if n <= 0:\n    return []\n  elif n == 1:\n    return [0]\n  else:\n    list_fib = [0, 1]\n    while len(list_fib) < n:\n      next_fib = list_fib[-1] + list_fib[-2]\n      list_fib.append(next_fib)\n    return list_fib\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def fib(n):\n  \"\"\"\n  This function returns a list with the first n elements of the Fibonacci sequence.\n\n  Args:\n    n: The number of Fibonacci elements to generate.\n\n  Returns:\n    A list containing the first n Fibonacci numbers.\n  \"\"\"\n  if n <= 0:\n    return []\n  elif n == 1:\n    return [0]\n  else:\n    list_fib = [0, 1]\n    while len(list_fib) < n:\n      next_fib = list_fib[-1] + list_fib[-2]\n      list_fib.append(next_fib)\n    return list_fib\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first `n` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciListZeroShot", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function fib(n) with input length n that returns a list with the first `n` elements of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction fib(n) {\n  if (n <= 0) {\n    return [];\n  } else if (n === 1) {\n    return [0];\n  } else {\n    let fibonacciSequence = [0, 1];\n    for (let i = 2; i < n; i++) {\n      fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\n    }\n    return fibonacciSequence;\n  }\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function fib(n) {\n  if (n <= 0) {\n    return [];\n  } else if (n === 1) {\n    return [0];\n  } else {\n    let fibonacciSequence = [0, 1];\n    for (let i = 2; i < n; i++) {\n      fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\n    }\n    return fibonacciSequence;\n  }\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function glork(bork) with input length bork that returns a list with the first `bork` elements of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef glork(bork):\n  \"\"\"\n  Returns a list with the first 'bork' elements of the Fibonacci sequence.\n\n  Args:\n    bork: An integer representing the desired length of the Fibonacci sequence.\n\n  Returns:\n    A list containing the first 'bork' Fibonacci numbers.\n  \"\"\"\n  fib_sequence = []\n  a = 0\n  b = 1\n  for _ in range(bork):\n    fib_sequence.append(a)\n    a, b = b, a + b\n  return fib_sequence\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def glork(bork):\n  \"\"\"\n  Returns a list with the first 'bork' elements of the Fibonacci sequence.\n\n  Args:\n    bork: An integer representing the desired length of the Fibonacci sequence.\n\n  Returns:\n    A list containing the first 'bork' Fibonacci numbers.\n  \"\"\"\n  fib_sequence = []\n  a = 0\n  b = 1\n  for _ in range(bork):\n    fib_sequence.append(a)\n    a, b = b, a + b\n  return fib_sequence\n\n#", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first `bork` elements of the fibonacci sequence", "Fact": "The fibonacci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciListMisnamed", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function glork(bork) with input length bork that returns a list with the first `bork` elements of the fibonacci sequence<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction glork(bork) {\n  if (bork <= 0) {\n    return [];\n  } else if (bork === 1) {\n    return [0];\n  } else {\n    let fibSequence = [0, 1];\n    for (let i = 2; i < bork; i++) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n    return fibSequence;\n  }\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function glork(bork) {\n  if (bork <= 0) {\n    return [];\n  } else if (bork === 1) {\n    return [0];\n  } else {\n    let fibSequence = [0, 1];\n    for (let i = 2; i < bork; i++) {\n      fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];\n    }\n    return fibSequence;\n  }\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 1], "status": 1}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 1, 2, 3], "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 8, "total": 8}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "python", "prompt": "<bos><start_of_turn>user\nWrite a python function substrcount(str, substr) with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`<end_of_turn>\n<start_of_turn>model\n", "answer": "```python\ndef substrcount(str, substr):\n  \"\"\"\n  Counts the number of times a substring occurs in a string.\n\n  Args:\n    str: The string to search within.\n    substr: The substring to count.\n\n  Returns:\n    The number of times substr occurs in str.\n  \"\"\"\n  count = 0\n  start = 0\n  while True:\n    start = str.find(substr, start)\n    if start == -1:\n      break\n    count += 1\n    start += len(substr)  # Move past the found substring\n  return count\n\n# ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "def substrcount(str, substr):\n  \"\"\"\n  Counts the number of times a substring occurs in a string.\n\n  Args:\n    str: The string to search within.\n    substr: The substring to count.\n\n  Returns:\n    The number of times substr occurs in str.\n  \"\"\"\n  count = 0\n  start = 0\n  while True:\n    start = str.find(substr, start)\n    if start == -1:\n      break\n    count += 1\n    start += len(substr)  # Move past the found substring\n  return count\n\n#", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "substrcount(str, substr)", "Input": "with inputs `str` and `substr`", "Output": "counts the number of times the sub-string `substr` occurs in `str`", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "javascript", "prompt": "<bos><start_of_turn>user\nWrite a javascript function substrcount(str, substr) with inputs `str` and `substr` that returns counts the number of times the sub-string `substr` occurs in `str`<end_of_turn>\n<start_of_turn>model\n", "answer": "```javascript\nfunction substrcount(str, substr) {\n  let count = 0;\n  let pos = 0;\n\n  while (true) {\n    pos = str.indexOf(substr, pos);\n    if (pos === -1) break;\n    count++;\n    pos += substr.length; // Move past the found substring\n  }\n\n  return count;\n}\n\n// ", "params": "GenerationConfig {\n  \"bos_token_id\": 2,\n  \"cache_implementation\": \"hybrid\",\n  \"eos_token_id\": 1,\n  \"max_new_tokens\": 1024,\n  \"pad_token_id\": 0\n}\n", "model": "google-gemma-2-27b-it-nf4", "runtime": "transformers", "code": "function substrcount(str, substr) {\n  let count = 0;\n  let pos = 0;\n\n  while (true) {\n    pos = str.indexOf(substr, pos);\n    if (pos === -1) break;\n    count++;\n    pos += substr.length; // Move past the found substring\n  }\n\n  return count;\n}\n\n//", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 3, "status": 1}], "status": "PASS", "passed": 7, "total": 7}