VMAssembler:
    Signature: "assemble(program)"
    Input: "with a list input `program` each entry representing one line of program text"
    Output: |-
      returns a list of 8-bit integers representing the raw bytes for the given program, in the int8 range [-128,127].      

      The VM is very simple:
      
      - instructions are always 2 bytes and aligned
      - the only data type is signed 8-bit integers
      - only two working registers (called R0, R1)
      - an infinite stack is both working memory and output

      The assembler syntax is:

      [:label] OPCODE arg [# comment]

      - Optional label prefixed by : (used to specify jump targets)
      - Required OPCODE (see OPCODE table below)
      - Required arg (could be an 8-bit immediate or "@target" which means label offset)
      - Optional comment prefixed by # (should be ignored for assembly purposes)
      
      The valid OPCODE and their byte values and explanations of their arguments are:

      - NOOP=0 do nothing, ignore argument byte
      - HALT=127 stops the program and return the stack when argument byte is -1, otherwise NO-OP.
      - SKIPLTE=128 skip the next instruction if R0 is less then or equal to argument byte
      - SKIPGT=128 skip the next instruction if R0 is greater than the argument byte
      - JMPA=64 jump absolute to 2*address specified by argument byte
      - JMPR=65 jump relative by 2*address specified by argument byte
      - LOAD=4 loads the argument byte into R0
      - SWP=8 swaps R0 and R1, ignores argument byte
      - ACCUM=12 adds R0 and R1, stores result in R0 if argument is 0 and R1 otherwise
      - XOR=13 computes bitwise R0^R1, stores result in R0 if argument is 0 and R1 otherwise
      - ADD0=16 adds argument to R0 (signed 8bit math)
      - ADD1=17 adds argument to R1 (signed 8bit math)
      - PUSH=32 pushes to stack (output), R0 if argument is 0 otherwise R1
      - POP=33 pops R0 from stack, R0 if argument is 0 otherwise R1

      Important details:
      - 8-bit signed integer is the only possible data in this VM, so all values in the returned list must be in the range [-128, 127]
      - JMPA and JMPR opcodes take a @target label as the argument; remember to divide by 2 (since opcodes are always aligned we dont need to send LSB) and compute either relative or absolute address of the target depending on the opcode. 

    Description: "See if the model is capable of implementing a complex text to numeric transformation."
    Checks:
        two_arguments:
            assert: "len(f.args)"
            eq: 1
        function_name:
            assert: "f.name"
            eq: "assemble"
        input_name_0:
            assert: "f.args[0].name"
            eq: "program"
        test_noop:
            assert: f.call(["NOOP 42"])
            eq: [0,42]
            weight: 4
        test_noop_negative:
            assert: f.call(["NOOP -42"])
            eq: [0,-42]
            weight: 4            
        test_comments:
            assert: |-
              f.call(["NOOP 1 #comment"])
            eq: [0,1]
            weight: 4
        test_halts:
            assert: f.call(["NOOP 0","HALT 0","HALT -1"])
            eq: [0,0,127,0,127,-1]
            weight: 6
        test_labels:
            assert: |-
              f.call([
                "LOAD 4",
                "SWP 0",
                "label1: LOAD 6",
                "JMPA @label1"
              ])
            eq: [4,4,8,0,4,6,64,3]
            weight: 8