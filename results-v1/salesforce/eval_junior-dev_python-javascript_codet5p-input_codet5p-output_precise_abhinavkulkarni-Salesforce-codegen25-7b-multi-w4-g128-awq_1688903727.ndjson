{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the n-th element of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciZeroShot", "language": "python", "prompt": "# a function with input element number n (0 based) that returns the n-th element of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):\n", "answer": "\ndef fib(n):\n    if n < 2:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\nprint(\"fib(5) =\", fib(5))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def fib(n):\n    if n < 2:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)\n\n\nprint(\"fib(5) =\", fib(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(2)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(3)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(5)", "eq": 5, "got": 5, "status": 1}], "status": "PASS", "passed": 7, "total": 7}
{"Signature": "fib(n)", "Input": "with input element number n (0 based)", "Output": "the n-th element of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence", "name": "FibonacciZeroShot", "language": "javascript", "prompt": "\n// a function with input element number n (0 based) that returns the n-th element of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\n\nfunction fib(n) {\n\n    if (n < 2) return n;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the tribonacci sequence given The tribonnaci sequence is defined by the boundary conditions trib(0) == 0, trib(1) == 1 and the recursive relation trib(n) == trib(n-1) + trib(n-2) + trib(n-3)\nfunction trib(n) {\n    if (n < 3) return n;\n    else return trib(n - 1) + trib(n - 2) + trib(n - 3);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the pentatonic scale given The pentatonic scale is defined by the boundary conditions penta(0) == 0, penta(1) == 1 and the recursive relation penta(n) == penta(n-1) + penta(n-2) + penta(n-3) + penta(n-4)\nfunction penta(n) {\n    if (n < 4) return n;\n    else return penta(n - 1) + penta(n - 2) + penta(n - 3) + penta(n - 4);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the hexatonic scale given The hexatonic scale is defined by the boundary conditions hexa(0) == 0, hexa(1) == 1 and the recursive relation hexa(n) == hexa(n-1) + hexa(n-2) + hexa(n-3) + hexa(n-4) + hexa(n-5)\nfunction hexa(n) {\n    if (n < 5) return n;\n   \n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function fib(n) {\n\n    if (n < 2) return n;\n    else return fib(n - 1) + fib(n - 2);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the tribonacci sequence given The tribonnaci sequence is defined by the boundary conditions trib(0) == 0, trib(1) == 1 and the recursive relation trib(n) == trib(n-1) + trib(n-2) + trib(n-3)\nfunction trib(n) {\n    if (n < 3) return n;\n    else return trib(n - 1) + trib(n - 2) + trib(n - 3);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the pentatonic scale given The pentatonic scale is defined by the boundary conditions penta(0) == 0, penta(1) == 1 and the recursive relation penta(n) == penta(n-1) + penta(n-2) + penta(n-3) + penta(n-4)\nfunction penta(n) {\n    if (n < 4) return n;\n    else return penta(n - 1) + penta(n - 2) + penta(n - 3) + penta(n - 4);\n}\n\n// a function with input element number n (0 based) that returns the n-th element of the hexatonic scale given The hexatonic scale is defined by the boundary conditions hexa(0) == 0, hexa(1) == 1 and the recursive relation hexa(n) == hexa(n-1) + hexa(n-2) + hexa(n-3) + hexa(n-4) + hexa(n-5)\nfunction hexa(n) {\n    if (n < 5) return n;", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}, {"assert": "f.call(0)", "eq": 0, "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(1)", "eq": 1, "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(2)", "eq": 1, "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(3)", "eq": 2, "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(5)", "eq": 5, "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}], "status": "FAIL", "passed": 2, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first n elements of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence, explicitly asking for a list", "name": "FibonacciListZeroShot", "language": "python", "prompt": "# a function with input length n that returns a list with the first n elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef fib(n):\n", "answer": "\ndef fib(n):\n    if n <= 1:\n        return [0]\n    else:\n        return [fib(n - 2)[-1], fib(n - 1)[-1]]\n\n\nprint(fib(10))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def fib(n):\n    if n <= 1:\n        return [0]\n    else:\n        return [fib(n - 2)[-1], fib(n - 1)[-1]]\n\n\nprint(fib(10))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 0], "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 0], "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 0], "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 4, "total": 7}
{"Signature": "fib(n)", "Input": "with input length n", "Output": "a list with the first n elements of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence, explicitly asking for a list", "name": "FibonacciListZeroShot", "language": "javascript", "prompt": "\n// a function with input length n that returns a list with the first n elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction fib(n) {", "answer": "\n\nfunction fib(n) {\n\n    if (n === 0 || n === 1) return [0, 1];\n\n    let result = [];\n    for (let i = 2; i <= n; i++) {\n        result.push(result[i - 2] + result[i - 1]);\n    }\n    return result;\n}\n\nconsole.log(fib(10));\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function fib(n) {\n\n    if (n === 0 || n === 1) return [0, 1];\n\n    let result = [];\n    for (let i = 2; i <= n; i++) {\n        result.push(result[i - 2] + result[i - 1]);\n    }\n    return result;\n}\n\nconsole.log(fib(10));", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0, 1], "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": [null], "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [null, null], "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [null, null, null, null], "status": 0}, {"assert": "f.args[0].name", "eq": "n", "got": "n", "status": 1}], "status": "FAIL", "passed": 3, "total": 7}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first bork elements of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciMisnamed", "language": "python", "prompt": "# a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork(bork):\n", "answer": "\ndef glork(bork):\n    if bork < 2:\n        return [0]\n    else:\n        return [0, 1] + glork(bork - 1)[:-1] + glork(bork - 2)[1:]\n\n\n# a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork_memoized(bork):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        elif n < 2:\n            memo[n] = 0\n            return 0\n        else:\n            memo[n] = helper(n - 1) + helper(n - 2)\n            return memo[n]\n    return [helper(i) for i in range(bork)]\n\n\n# a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork_memoized_recursive(bork):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        elif n < 2:\n            memo[n] = 0\n            return 0\n        else:\n            memo[n] = helper(n - 1) + helper(n - 2)\n            return memo[n]\n    return [helper(i) for i in range(bork)]\n\n\n# a function with input length bork that returns a list with the first bork elements\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def glork(bork):\n    if bork < 2:\n        return [0]\n    else:\n        return [0, 1] + glork(bork - 1)[:-1] + glork(bork - 2)[1:]\n\n\n# a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork_memoized(bork):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        elif n < 2:\n            memo[n] = 0\n            return 0\n        else:\n            memo[n] = helper(n - 1) + helper(n - 2)\n            return memo[n]\n    return [helper(i) for i in range(bork)]\n\n\n# a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\ndef glork_memoized_recursive(bork):\n    memo = {}\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        elif n < 2:\n            memo[n] = 0\n            return 0\n        else:\n            memo[n] = helper(n - 1) + helper(n - 2)\n            return memo[n]\n    return [helper(i) for i in range(bork)]\n\n\n# a function with input length bork that returns a list with the first bork elements", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": [0], "got": [0], "status": 1}, {"assert": "f.call(2)", "eq": [0, 1], "got": [0, 1], "status": 1}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": [0, 1, 0], "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": [0, 1, 0, 1, 0, 1, 1, 0], "status": 0}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 6, "total": 8}
{"Signature": "glork(bork)", "Input": "with input length bork", "Output": "a list with the first bork elements of the fibbonaci sequence", "Fact": "The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)", "Description": "See if the model can produce a well known sequence if the name has been changed", "name": "FibonacciMisnamed", "language": "javascript", "prompt": "\n// a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {", "answer": "\n\nfunction glork(bork) {\n\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[i-1] + result[i-2]);\n    }\n    return result;\n}\n\n// a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[i-1] + result[i-2]);\n    }\n    return result;\n}\n\n// a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function glork(bork) {\n\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[i-1] + result[i-2]);\n    }\n    return result;\n}\n\n// a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[i-1] + result[i-2]);\n    }\n    return result;\n}\n\n// a function with input length bork that returns a list with the first bork elements of the fibbonaci sequence given The fibonnaci sequence is defined by the boundary conditions fib(0) == 0, fib(1) == 1 and the recursive relation fib(n) == fib(n-1) + fib(n-2)\nfunction glork(bork) {\n    if (bork < 2) return [0];\n    var result = [];\n    for (var i=0; i<bork; i++) {\n        if (i === 0) result.push(0);\n        else if (i === 1) result.push(1);\n        else result.push(result[", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(0),list)", "eq": true, "got": false, "status": 0}, {"assert": "f.call(1)", "eq": [0], "got": {"error": "Unexpected token 'var'", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(2)", "eq": [0, 1], "got": {"error": "Unexpected token 'var'", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(3)", "eq": [0, 1, 1], "got": {"error": "Unexpected token 'var'", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(5)", "eq": [0, 1, 1, 2, 3], "got": {"error": "Unexpected token 'var'", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "FAIL", "passed": 3, "total": 8}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "python", "prompt": "# a function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\ndef meaning_of_life():\n", "answer": "\ndef meaning_of_life():\n    return 42\n\n\n# a function with one input that returns the square of its argument\ndef square(x):\n    return x * x\n\n\n# a function with two inputs that returns their sum\ndef add(a, b):\n    return a + b\n\n\n# a function with three inputs that returns the product of its arguments\ndef multiply(a, b, c):\n    return a * b * c\n\n\n# a function with four inputs that returns the average of its arguments\ndef average(a, b, c, d):\n    return (a + b + c + d) / 4.0\n\n\n# a function with five inputs that returns the median of its arguments\ndef median(a, b, c, d, e):\n    return (a + b + c + d + e) / 5.0\n\n\n# a function with six inputs that returns the mode of its arguments\ndef mode(a, b, c, d, e, f):\n    return [a, b, c, d, e, f]\n\n\n# a function with seven inputs that returns the standard deviation of its arguments\ndef std_deviation(a, b, c, d, e, f, g):\n    return math.sqrt(((a - g) ** 2 + (b - g) ** 2 + (c - g) ** 2 + (d - g) ** 2 + (e - g) ** 2 + (f - g) ** 2) / 7.0)\n\n\n# a function with eight inputs that returns the variance of its arguments\ndef variance(a, b, c, d, e, f, g, h):\n    return ((a - h) ** 2 + (b - h) ** 2 + (c - h) ** 2 + (d - h) ** 2 + (e - h) ** 2 + (f - h) ** 2 + (g - h) ** 2) / 8.0\n\n\n# a function with nine inputs that returns the covariance of its arguments\ndef covariance(a, b, c, d, e, f, g, h, i):\n    return ((a - i) * (b\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def meaning_of_life():\n    return 42\n\n\n# a function with one input that returns the square of its argument\ndef square(x):\n    return x * x\n\n\n# a function with two inputs that returns their sum\ndef add(a, b):\n    return a + b\n\n\n# a function with three inputs that returns the product of its arguments\ndef multiply(a, b, c):\n    return a * b * c\n\n\n# a function with four inputs that returns the average of its arguments\ndef average(a, b, c, d):\n    return (a + b + c + d) / 4.0\n\n\n# a function with five inputs that returns the median of its arguments\ndef median(a, b, c, d, e):\n    return (a + b + c + d + e) / 5.0\n\n\n# a function with six inputs that returns the mode of its arguments\ndef mode(a, b, c, d, e, f):\n    return [a, b, c, d, e, f]\n\n\n# a function with seven inputs that returns the standard deviation of its arguments\ndef std_deviation(a, b, c, d, e, f, g):\n    return math.sqrt(((a - g) ** 2 + (b - g) ** 2 + (c - g) ** 2 + (d - g) ** 2 + (e - g) ** 2 + (f - g) ** 2) / 7.0)\n\n\n# a function with eight inputs that returns the variance of its arguments\ndef variance(a, b, c, d, e, f, g, h):\n    return ((a - h) ** 2 + (b - h) ** 2 + (c - h) ** 2 + (d - h) ** 2 + (e - h) ** 2 + (f - h) ** 2 + (g - h) ** 2) / 8.0\n\n\n# a function with nine inputs that returns the covariance of its arguments\ndef covariance(a, b, c, d, e, f, g, h, i):\n    return ((a - i) * (b", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": {"error": "unexpected EOF while parsing (<string>, line 47)", "exc_type": "SyntaxError"}, "status": 0}], "status": "FAIL", "passed": 2, "total": 3}
{"Signature": "meaning_of_life()", "Input": "with no inputs", "Output": "a single integer, the answer to life the universe and everything", "Fact": "the answer to life the universe and everything is 42", "Description": "Scalar function with no arguments, see if the model can use its internal knowledge to both code and summon a fact from pop culture.", "name": "SanityMeaningOfLife", "language": "javascript", "prompt": "\n// a function with no inputs that returns a single integer, the answer to life the universe and everything given the answer to life the universe and everything is 42\nfunction meaning_of_life() {", "answer": "\n\nfunction meaning_of_life() {\n\n    return 42;\n}\n\n// a function with one input that takes an array of integers and returns the sum of all elements in the array\nfunction sum(array) {\n    var total = 0;\n    for (var i=0; i<array.length; i++) {\n        total += array[i];\n    }\n    return total;\n}\n\n// a function with two inputs: an array of integers and a number n, where n <= the length of the array, \n// that returns the first n elements of the array\nfunction take(array, n) {\n    if (n > array.length) {\n        throw \"Error: n must be less than or equal to the length of the array\";\n    }\n    var result = [];\n    for (var i=0; i<n; i++) {\n        result.push(array[i]);\n    }\n    return result;\n}\n\n// a function with three inputs: an array of integers, a number m, and a number n, where m < n <= the length of the array, \n// that returns the first m elements of the array after skipping the first n elements\nfunction drop(array, m, n) {\n    if (m >= n || n > array.length) {\n        throw \"Error: m must be strictly smaller than n and n must be less than or equal to the length of the array\";\n    }\n    var result = [];\n    for (var i=n; i<array.length; i++) {\n        result.push(array[i]);\n    }\n    return result;\n}\n\n// a function with four inputs: an array of integers, a number m, a number n, and a number k, where m < n <= the length of the array, \n// that returns the first k elements of the array after skipping the first m elements and taking only the next n-k elements\nfunction slice(array, m, n, k) {\n    if (m >= n || n > array.length) {\n        throw \"Error: m must be strictly smaller than n and n must be less than or\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function meaning_of_life() {\n\n    return 42;\n}\n\n// a function with one input that takes an array of integers and returns the sum of all elements in the array\nfunction sum(array) {\n    var total = 0;\n    for (var i=0; i<array.length; i++) {\n        total += array[i];\n    }\n    return total;\n}\n\n// a function with two inputs: an array of integers and a number n, where n <= the length of the array, \n// that returns the first n elements of the array\nfunction take(array, n) {\n    if (n > array.length) {\n        throw \"Error: n must be less than or equal to the length of the array\";\n    }\n    var result = [];\n    for (var i=0; i<n; i++) {\n        result.push(array[i]);\n    }\n    return result;\n}\n\n// a function with three inputs: an array of integers, a number m, and a number n, where m < n <= the length of the array, \n// that returns the first m elements of the array after skipping the first n elements\nfunction drop(array, m, n) {\n    if (m >= n || n > array.length) {\n        throw \"Error: m must be strictly smaller than n and n must be less than or equal to the length of the array\";\n    }\n    var result = [];\n    for (var i=n; i<array.length; i++) {\n        result.push(array[i]);\n    }\n    return result;\n}\n\n// a function with four inputs: an array of integers, a number m, a number n, and a number k, where m < n <= the length of the array, \n// that returns the first k elements of the array after skipping the first m elements and taking only the next n-k elements\nfunction slice(array, m, n, k) {\n    if (m >= n || n > array.length) {\n        throw \"Error: m must be strictly smaller than n and n must be less than or", "checks": [{"assert": "f.name", "eq": "meaning_of_life", "got": "meaning_of_life", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": 42, "got": {"error": "Invalid or unexpected token", "exc_type": "SyntaxError"}, "status": 0}], "status": "FAIL", "passed": 2, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "List function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "python", "prompt": "# a function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\ndef things():\n", "answer": "\ndef things():\n    return [5, \"foobar\", \"Madrid\"]\n\nprint(things())\n\n# a function with one input (a number) and two outputs (the square root of the number and the cube root of the number)\ndef math_functions(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3\n    return [sqrt, cubed]\n\nprint(math_functions(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_square_root(number):\n    sqrt = number ** 0.5\n    print(\"The square root of {} is {}\".format(number, sqrt))\n    return sqrt\n\nprint(print_square_root(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_cube_root(number):\n    cubed = number ** 3\n    print(\"The cube root of {} is {}\".format(number, cubed))\n    return cubed\n\nprint(print_cube_root(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_both(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3\n    print(\"The square root of {} is {}, and the cube root of {} is {}\".format(number, sqrt, number, cubed))\n    return [sqrt, cubed]\n\nprint(print_both(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_all(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3\n   \n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def things():\n    return [5, \"foobar\", \"Madrid\"]\n\nprint(things())\n\n# a function with one input (a number) and two outputs (the square root of the number and the cube root of the number)\ndef math_functions(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3\n    return [sqrt, cubed]\n\nprint(math_functions(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_square_root(number):\n    sqrt = number ** 0.5\n    print(\"The square root of {} is {}\".format(number, sqrt))\n    return sqrt\n\nprint(print_square_root(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_cube_root(number):\n    cubed = number ** 3\n    print(\"The cube root of {} is {}\".format(number, cubed))\n    return cubed\n\nprint(print_cube_root(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_both(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3\n    print(\"The square root of {} is {}, and the cube root of {} is {}\".format(number, sqrt, number, cubed))\n    return [sqrt, cubed]\n\nprint(print_both(9))\n\n# a function with one input (a number), one output (the square root of the number), and one side effect (prints out the square root of the number to the screen)\ndef print_all(number):\n    sqrt = number ** 0.5\n    cubed = number ** 3", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": [5, "foobar", "Madrid"], "got": [5, "foobar", "Madrid"], "status": 1}], "status": "PASS", "passed": 3, "total": 3}
{"Signature": "things()", "Input": "with no inputs", "Output": "a list with three values: the number 5, the string 'foobar', the capital city of Spain", "Fact": "the capital city of Spain is Madrid", "Description": "List function, see if the model can combine input facts with internal knowledge.", "name": "SanityList", "language": "javascript", "prompt": "\n// a function with no inputs that returns a list with three values: the number 5, the string 'foobar', the capital city of Spain given the capital city of Spain is Madrid\nfunction things() {", "answer": "\n\nfunction things() {\n\n    return [5, \"foobar\", \"Madrid\"];\n}\n\n// a function with one input (a number) and two outputs (the square root of the number and the cube root of the number). The output should be rounded to 3 decimal places.\nfunction numbers(num) {\n    let sqrt = Math.sqrt(num);\n    let cbrt = Math.cbrt(num);\n\n    return [Math.round(sqrt * 1000) / 1000, Math.round(cbrt * 1000) / 1000];\n}\n\n// a function with one input (a number) and one output (the factorial of the number). The output should be rounded to 3 decimal places.\nfunction factorials(num) {\n    if (num < 0) {\n        throw new Error(\"Factorial does not exist for negative numbers\");\n    } else if (num === 0 || num === 1) {\n        return 1;\n    } else {\n        let result = 1;\n        for (let i = 2; i <= num; i++) {\n            result *= i;\n        }\n        return Math.round(result * 1000) / 1000;\n    }\n}\n\n// a function with one input (a number) and one output (the sum of all the digits in the number). The output should be rounded to 3 decimal places.\nfunction digitSum(num) {\n    let sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num = parseInt(num / 10);\n    }\n    return Math.round(sum * 1000) / 1000;\n}\n\n// a function with one input (a number) and one output (the average of all the digits in the number). The output should be rounded to 3 decimal places.\nfunction digitAverage(num) {\n    let sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num = parseInt(num / 10);\n    }\n    return Math.round((sum / num.toString().length) * 1000) / 1000;\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function things() {\n\n    return [5, \"foobar\", \"Madrid\"];\n}\n\n// a function with one input (a number) and two outputs (the square root of the number and the cube root of the number). The output should be rounded to 3 decimal places.\nfunction numbers(num) {\n    let sqrt = Math.sqrt(num);\n    let cbrt = Math.cbrt(num);\n\n    return [Math.round(sqrt * 1000) / 1000, Math.round(cbrt * 1000) / 1000];\n}\n\n// a function with one input (a number) and one output (the factorial of the number). The output should be rounded to 3 decimal places.\nfunction factorials(num) {\n    if (num < 0) {\n        throw new Error(\"Factorial does not exist for negative numbers\");\n    } else if (num === 0 || num === 1) {\n        return 1;\n    } else {\n        let result = 1;\n        for (let i = 2; i <= num; i++) {\n            result *= i;\n        }\n        return Math.round(result * 1000) / 1000;\n    }\n}\n\n// a function with one input (a number) and one output (the sum of all the digits in the number). The output should be rounded to 3 decimal places.\nfunction digitSum(num) {\n    let sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num = parseInt(num / 10);\n    }\n    return Math.round(sum * 1000) / 1000;\n}\n\n// a function with one input (a number) and one output (the average of all the digits in the number). The output should be rounded to 3 decimal places.\nfunction digitAverage(num) {\n    let sum = 0;\n    while (num > 0) {\n        sum += num % 10;\n        num = parseInt(num / 10);\n    }\n    return Math.round((sum / num.toString().length) * 1000) / 1000;", "checks": [{"assert": "f.name", "eq": "things", "got": "things", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call()", "eq": [5, "foobar", "Madrid"], "got": {"error": "Unexpected end of input", "exc_type": "SyntaxError"}, "status": 0}], "status": "FAIL", "passed": 2, "total": 3}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "python", "prompt": "# a function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\ndef secretidentities():\n", "answer": "\ndef secretidentities():\n    return {'Superman': '<NAME>', 'Batman': '<NAME>', 'Spider-Man': '<NAME>'}\n\n\n# a function with one input (a string) that prints out all of the characters in the string on separate lines. For example:\n# print_characters('abc') should print out each character on its own line.\ndef print_characters(string):\n    for char in string:\n        print(char)\n\n\n# a function with two inputs (strings) that returns True if the first string contains every character from the second string. For example:\n# contains_all('abcd', 'bce') should return False because b does not appear in abcd.\n# contains_all('abcd', 'bcde') should return True because e appears in bcde.\ndef contains_all(str1, str2):\n    for char in str2:\n        if char not in str1:\n            return False\n    return True\n\n\n# a function with three inputs (two strings and a boolean value) that returns True if the first string contains every character from the second string, but only if they are in order. If they aren't in order, then it returns False. For example:\n# contains_in_order('abcd', 'bcef', True) should return False because d doesn't come before e.\n# contains_in_order('abcd', 'cbad', False) should return True because c comes before b.\n# contains_in_order('abcd', 'cbda', True) should return False because d comes after b.\ndef contains_in_order(str1, str2, ordered=True):\n    i = 0\n    for char in str2:\n        if i >= len(str1):\n            return False\n        elif str1[i] != char:\n            return False\n        else:\n            i += 1\n    return True\n\n\n# a function with four inputs (three strings and a boolean value) that returns True if the first string contains every character from the second string\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def secretidentities():\n    return {'Superman': '<NAME>', 'Batman': '<NAME>', 'Spider-Man': '<NAME>'}\n\n\n# a function with one input (a string) that prints out all of the characters in the string on separate lines. For example:\n# print_characters('abc') should print out each character on its own line.\ndef print_characters(string):\n    for char in string:\n        print(char)\n\n\n# a function with two inputs (strings) that returns True if the first string contains every character from the second string. For example:\n# contains_all('abcd', 'bce') should return False because b does not appear in abcd.\n# contains_all('abcd', 'bcde') should return True because e appears in bcde.\ndef contains_all(str1, str2):\n    for char in str2:\n        if char not in str1:\n            return False\n    return True\n\n\n# a function with three inputs (two strings and a boolean value) that returns True if the first string contains every character from the second string, but only if they are in order. If they aren't in order, then it returns False. For example:\n# contains_in_order('abcd', 'bcef', True) should return False because d doesn't come before e.\n# contains_in_order('abcd', 'cbad', False) should return True because c comes before b.\n# contains_in_order('abcd', 'cbda', True) should return False because d comes after b.\ndef contains_in_order(str1, str2, ordered=True):\n    i = 0\n    for char in str2:\n        if i >= len(str1):\n            return False\n        elif str1[i] != char:\n            return False\n        else:\n            i += 1\n    return True\n\n\n# a function with four inputs (three strings and a boolean value) that returns True if the first string contains every character from the second string", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq": "Clark Kent", "got": "<NAME>", "status": 0}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "<NAME>", "status": 0}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "<NAME>", "status": 0}], "status": "FAIL", "passed": 2, "total": 5}
{"Signature": "secretidentities()", "Input": "with no inputs", "Output": "an object mapping the superheroes Superman, Batman and Spider-Man to their real names", "Fact": "Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.", "Description": "Object function, see if the model can use its internal knowledge to build a map.", "name": "SanitySecretIdentityMap", "language": "javascript", "prompt": "\n// a function with no inputs that returns an object mapping the superheroes Superman, Batman and Spider-Man to their real names given Superman's real name is Clark Kent. Batman's real name is Bruce Wayne. Spider-Man's real name is Peter Parker.\nfunction secretidentities() {", "answer": "\n\nfunction secretidentities() {\n\n    return {\n        \"Superman\": \"<NAME>\",\n        \"Batman\": \"<NAME>\",\n        \"Spider-Man\": \"<NAME>\"\n    };\n}\n\n// a function with one input (a string) that returns true if the string contains the word 'super' anywhere in it.\nfunction superhero(name) {\n    var result = false;\n    for (var i=0; i<name.length; i++) {\n        if (name[i] == \"s\" || name[i] == \"S\") {\n            result = true;\n        }\n    }\n    return result;\n}\n\n// a function with two inputs (an array of strings and a number n). The function should return an array containing only the first n elements from the original array. If n is greater than or equal to the length of the array, then the entire array should be returned.\nfunction takefirstn(array, n) {\n    var newArray = [];\n    for (var i=0; i<n && i<array.length; i++) {\n        newArray.push(array[i]);\n    }\n    return newArray;\n}\n\n// a function with three inputs: an array of numbers, a number m and a number n. The function should return an array containing all the numbers between m and n (inclusive), but not including any numbers outside this range. For example, [1,2,3,4,5] would become [2,3,4].\nfunction numrange(array, m, n) {\n    var newArray = [];\n    for (var i=m; i<=n; i++) {\n        newArray.push(i);\n    }\n    return newArray;\n}\n\n// a function with four inputs: an array of objects, a property name, a value and a boolean indicating whether the value should be included or excluded. The function should return an array containing only those objects where the specified property has the specified value. If the boolean is true, then include the value, otherwise exclude it\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function secretidentities() {\n\n    return {\n        \"Superman\": \"<NAME>\",\n        \"Batman\": \"<NAME>\",\n        \"Spider-Man\": \"<NAME>\"\n    };\n}\n\n// a function with one input (a string) that returns true if the string contains the word 'super' anywhere in it.\nfunction superhero(name) {\n    var result = false;\n    for (var i=0; i<name.length; i++) {\n        if (name[i] == \"s\" || name[i] == \"S\") {\n            result = true;\n        }\n    }\n    return result;\n}\n\n// a function with two inputs (an array of strings and a number n). The function should return an array containing only the first n elements from the original array. If n is greater than or equal to the length of the array, then the entire array should be returned.\nfunction takefirstn(array, n) {\n    var newArray = [];\n    for (var i=0; i<n && i<array.length; i++) {\n        newArray.push(array[i]);\n    }\n    return newArray;\n}\n\n// a function with three inputs: an array of numbers, a number m and a number n. The function should return an array containing all the numbers between m and n (inclusive), but not including any numbers outside this range. For example, [1,2,3,4,5] would become [2,3,4].\nfunction numrange(array, m, n) {\n    var newArray = [];\n    for (var i=m; i<=n; i++) {\n        newArray.push(i);\n    }\n    return newArray;\n}\n\n// a function with four inputs: an array of objects, a property name, a value and a boolean indicating whether the value should be included or excluded. The function should return an array containing only those objects where the specified property has the specified value. If the boolean is true, then include the value, otherwise exclude it", "checks": [{"assert": "f.name", "eq": "secretidentities", "got": "secretidentities", "status": 1}, {"assert": "len(f.args)", "eq": 0, "got": 0, "status": 1}, {"assert": "f.call().get('Superman')", "eq": "Clark Kent", "got": "<NAME>", "status": 0}, {"assert": "f.call().get('Batman')", "eq": "Bruce Wayne", "got": "<NAME>", "status": 0}, {"assert": "f.call().get('Spider-Man')", "eq": "Peter Parker", "got": "<NAME>", "status": 0}], "status": "FAIL", "passed": 2, "total": 5}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common demoninator (gcd) of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "python", "prompt": "# a function with two inputs a and b that returns the greatest common demoninator (gcd) of a and b\ndef gcd(a, b):\n", "answer": "\ndef gcd(a, b):\n    if a < 0:\n        return -1 * gcd(-1*a, b)\n    elif b < 0:\n        return -1 * gcd(a, -1*b)\n\n    # base case\n    if a == 0 or b == 0:\n        return max(abs(a), abs(b))\n\n    # recursive step\n    if a > b:\n        return gcd(a-b, b)\n    else:\n        return gcd(a, b-a)\n\nprint(\"The GCD is\", gcd(10, 5))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def gcd(a, b):\n    if a < 0:\n        return -1 * gcd(-1*a, b)\n    elif b < 0:\n        return -1 * gcd(a, -1*b)\n\n    # base case\n    if a == 0 or b == 0:\n        return max(abs(a), abs(b))\n\n    # recursive step\n    if a > b:\n        return gcd(a-b, b)\n    else:\n        return gcd(a, b-a)\n\nprint(\"The GCD is\", gcd(10, 5))", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,10)", "eq": 10, "got": 10, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "gcd(a, b)", "Input": "with two inputs a and b", "Output": "the greatest common demoninator (gcd) of a and b", "Description": "See if the model can output a well-known, simple algorithm.", "name": "GCDZeroShot", "language": "javascript", "prompt": "\n// a function with two inputs a and b that returns the greatest common demoninator (gcd) of a and b\nfunction gcd(a, b) {", "answer": "\n\nfunction gcd(a, b) {\n\n    if (b === 0) return a;\n    else return gcd(b, a % b);\n}\n\n// a function with one input n that returns an array containing all prime numbers less than or equal to n\nfunction primes(n) {\n    var arr = [];\n    for (var i = 2; i <= n; i++) {\n        var isPrime = true;\n        for (var j = 2; j < i; j++) {\n            if (i % j === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) arr.push(i);\n    }\n    return arr;\n}\n\n// a function with three inputs a, b, c that returns the least common multiple (lcm) of a, b, and c\nfunction lcm(a, b, c) {\n    return Math.abs((a * b * c) / gcd(a, gcd(b, c)));\n}\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function gcd(a, b) {\n\n    if (b === 0) return a;\n    else return gcd(b, a % b);\n}\n\n// a function with one input n that returns an array containing all prime numbers less than or equal to n\nfunction primes(n) {\n    var arr = [];\n    for (var i = 2; i <= n; i++) {\n        var isPrime = true;\n        for (var j = 2; j < i; j++) {\n            if (i % j === 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        if (isPrime) arr.push(i);\n    }\n    return arr;\n}\n\n// a function with three inputs a, b, c that returns the least common multiple (lcm) of a, b, and c\nfunction lcm(a, b, c) {\n    return Math.abs((a * b * c) / gcd(a, gcd(b, c)));\n}", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(100,10)", "eq": 10, "got": 10, "status": 1}, {"assert": "f.args[0].name", "eq": "a", "got": "a", "status": 1}, {"assert": "f.args[1].name", "eq": "b", "got": "b", "status": 1}], "status": "PASS", "passed": 5, "total": 5}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common demoninator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "python", "prompt": "# a function with two inputs x and banana that returns the greatest common demoninator (gcd) of x and banana\ndef fofx(x, banana):\n", "answer": "\ndef fofx(x, banana):\n    return gcd(x, banana)\n\n\n# a function with one input x that returns the least common multiple (lcm) of x and banana\ndef flox(x):\n    return lcm(x, banana)\n\n\n# a function with three inputs x, y, z that returns the sum of all numbers between x and z inclusive\ndef fxyz(x, y, z):\n    return sum_between(x, y, z)\n\n\n# a function with four inputs x, y, z, w that returns the product of all numbers between x and z inclusive\ndef fxyzw(x, y, z, w):\n    return prod_between(x, y, z, w)\n\n\n# a function with five inputs x, y, z, w, v that returns the factorial of all numbers between x and z inclusive\ndef fxyzwv(x, y, z, w, v):\n    return fac_between(x, y, z, w, v)\n\n\n# a function with six inputs x, y, z, w, v, u that returns the binomial coefficient of all numbers between x and z inclusive\ndef fxyzwu(x, y, z, w, v, u):\n    return bino_between(x, y, z, w, v, u)\n\n\n# a function with seven inputs x, y, z, w, v, u, t that returns the hypergeometric function of all numbers between x and z inclusive\ndef fxyzwt(x, y, z, w, v, u, t):\n    return hypo_between(x, y, z, w, v, u, t)\n\n\n# a function with eight inputs x, y, z, w, v, u, t, s that returns the gamma function of all numbers between x and z inclusive\ndef fxyzws(x, y, z, w, v, u, t, s):\n    return gamma_between(x, y, z, w, v, u, t, s)\n\n\n# a function with nine inputs x, y, z, w, v, u, t, s\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def fofx(x, banana):\n    return gcd(x, banana)\n\n\n# a function with one input x that returns the least common multiple (lcm) of x and banana\ndef flox(x):\n    return lcm(x, banana)\n\n\n# a function with three inputs x, y, z that returns the sum of all numbers between x and z inclusive\ndef fxyz(x, y, z):\n    return sum_between(x, y, z)\n\n\n# a function with four inputs x, y, z, w that returns the product of all numbers between x and z inclusive\ndef fxyzw(x, y, z, w):\n    return prod_between(x, y, z, w)\n\n\n# a function with five inputs x, y, z, w, v that returns the factorial of all numbers between x and z inclusive\ndef fxyzwv(x, y, z, w, v):\n    return fac_between(x, y, z, w, v)\n\n\n# a function with six inputs x, y, z, w, v, u that returns the binomial coefficient of all numbers between x and z inclusive\ndef fxyzwu(x, y, z, w, v, u):\n    return bino_between(x, y, z, w, v, u)\n\n\n# a function with seven inputs x, y, z, w, v, u, t that returns the hypergeometric function of all numbers between x and z inclusive\ndef fxyzwt(x, y, z, w, v, u, t):\n    return hypo_between(x, y, z, w, v, u, t)\n\n\n# a function with eight inputs x, y, z, w, v, u, t, s that returns the gamma function of all numbers between x and z inclusive\ndef fxyzws(x, y, z, w, v, u, t, s):\n    return gamma_between(x, y, z, w, v, u, t, s)\n\n\n# a function with nine inputs x, y, z, w, v, u, t, s", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.call(100,10)", "eq": 10, "got": {"error": "name 'gcd' is not defined", "exc_type": "NameError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "FAIL", "passed": 4, "total": 6}
{"Signature": "fofx(x, banana)", "Input": "with two inputs x and banana", "Output": "the greatest common demoninator (gcd) of x and banana", "Description": "See if the model can output a well-known, simple algorithm if the name has been changed.", "name": "GCDMisnamed", "language": "javascript", "prompt": "\n// a function with two inputs x and banana that returns the greatest common demoninator (gcd) of x and banana\nfunction fofx(x, banana) {", "answer": "\n\nfunction fofx(x, banana) {\n\n    return gcd(x, banana);\n}\n\nconsole.log(\"The GCD of 5 and 10 is: \" + fofx(5,10));\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function fofx(x, banana) {\n\n    return gcd(x, banana);\n}\n\nconsole.log(\"The GCD of 5 and 10 is: \" + fofx(5,10));", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.call(1,1)", "eq": 1, "got": {"error": "gcd is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.call(100,10)", "eq": 10, "got": {"error": "gcd is not defined", "exc_type": "ReferenceError"}, "status": 0}, {"assert": "f.args[0].name", "eq": "x", "got": "x", "status": 1}, {"assert": "f.args[1].name", "eq": "banana", "got": "banana", "status": 1}, {"assert": "f.name", "eq": "fofx", "got": "fofx", "status": 1}], "status": "FAIL", "passed": 4, "total": 6}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "python", "prompt": "# a function with input n that returns the factorial of n using iteration\ndef factorial(n):\n", "answer": "\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n\nprint(\"The factorial of 5 is\", factorial(5))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\n\nprint(\"The factorial of 5 is\", factorial(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using iteration", "Description": "See if the model can implement a well known function", "name": "FactorialZeroShot", "language": "javascript", "prompt": "\n// a function with input n that returns the factorial of n using iteration\nfunction factorial(n) {", "answer": "\n\nfunction factorial(n) {\n\n  let result = 1;\n\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n\n  return result;\n}\n\nconsole.log(factorial(5)); // 120\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function factorial(n) {\n\n  let result = 1;\n\n  for (let i = 2; i <= n; i++) {\n    result *= i;\n  }\n\n  return result;\n}\n\nconsole.log(factorial(5)); // 120", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "python", "prompt": "# a function with input n that returns the factorial of n using recursion\ndef factorial(n):\n", "answer": "\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\nprint(\"The factorial of 5 is\", factorial(5))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n\nprint(\"The factorial of 5 is\", factorial(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "factorial(n)", "Input": "with input n", "Output": "the factorial of n using recursion", "Description": "See if the model can implement a well known function using recursion", "name": "FactorialRecursiveZeroShot", "language": "javascript", "prompt": "\n// a function with input n that returns the factorial of n using recursion\nfunction factorial(n) {", "answer": "\n\nfunction factorial(n) {\n\n    if (n === 0 || n === 1) return 1;\n    else return n * factorial(n - 1);\n}\n\nconsole.log(\"factorial(5):\", factorial(5)); // 120\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function factorial(n) {\n\n    if (n === 0 || n === 1) return 1;\n    else return n * factorial(n - 1);\n}\n\nconsole.log(\"factorial(5):\", factorial(5)); // 120", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}], "status": "PASS", "passed": 4, "total": 4}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "python", "prompt": "# a function with input bork that returns the factorial of bork\ndef glork(bork):\n", "answer": "\ndef glork(bork):\n    if bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)\n\n\nprint(\"The factorial of 5 is\", glork(5))\n\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def glork(bork):\n    if bork == 0:\n        return 1\n    else:\n        return bork * glork(bork - 1)\n\n\nprint(\"The factorial of 5 is\", glork(5))", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 1, "status": 1}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": true, "status": 1}, {"assert": "f.call(1)", "eq": 1, "got": 1, "status": 1}, {"assert": "f.call(5)", "eq": 120, "got": 120, "status": 1}, {"assert": "f.args[0].name", "eq": "bork", "got": "bork", "status": 1}, {"assert": "f.name", "eq": "glork", "got": "glork", "status": 1}], "status": "PASS", "passed": 6, "total": 6}
{"Signature": "glork(bork)", "Input": "with input bork", "Output": "the factorial of bork", "Description": "See if the model can implement a well known function if the name has been changed", "name": "FactorialMisnamed", "language": "javascript", "prompt": "\n// a function with input bork that returns the factorial of bork\nfunction glork(bork) {", "answer": "\n\nfunction glork(bork) {\n\n  return bork * (bork - 1);\n}\n\nconsole.log(\"glork(3):\", glork(3)); // 6\n```\n\n## What is an IIFE?\n\nIIFE stands for \"Immediately Invoked Function Expression\". It's a way to create a function and immediately invoke it, so you can use its output without having to store it in a variable.\n\nHere's how we would write our `factorial()` function as an IIFE:\n\n```js\nconst factorial = (num) => {\n  let result = num;\n\n  while (num > 1) {\n    result *= num--;\n  }\n\n  return result;\n};\n\nconsole.log(\"factorial(5)\", factorial(5)); // 120\n```\n\nWe could also rewrite this using arrow functions:\n\n```js\nconst factorial = (num) => {\n  let result = num;\n\n  while (num > 1) {\n    result *= num--;\n  }\n\n  return result;\n};\n\nconsole.log(\"factorial(5)\", factorial(5)); // 120\n```\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "## What is an IIFE?\n\nIIFE stands for \"Immediately Invoked Function Expression\". It's a way to create a function and immediately invoke it, so you can use its output without having to store it in a variable.\n\nHere's how we would write our `factorial()` function as an IIFE:", "checks": [{"assert": "len(f.args)", "eq": 1, "got": 0, "status": 0}, {"assert": "isinstance(f.call(1),int)", "eq": true, "got": false, "status": 0}, {"assert": "f.call(1)", "eq": 1, "got": {"error": "non-zero result code 2", "output": ""}, "status": 0}, {"assert": "f.call(5)", "eq": 120, "got": {"error": "non-zero result code 2", "output": ""}, "status": 0}, {"assert": "f.args[0].name", "eq": "bork", "got": "list index out of range", "status": 0}, {"assert": "f.name", "eq": "glork", "got": "", "status": 0}], "status": "FAIL", "passed": 0, "total": 6}
{"Signature": "substrcount(str, substr)", "Input": "with inputs str and substr", "Output": "counts the number of times the sub-string substr occurs in str", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "python", "prompt": "# a function with inputs str and substr that returns counts the number of times the sub-string substr occurs in str\ndef substrcount(str, substr):\n", "answer": "\ndef substrcount(str, substr):\n    count = 0\n    for i in range(len(str) - len(substr) + 1):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count\n\n\n# a function with inputs str1 and str2 that returns True if str1 is a subsequence of str2\ndef is_subsequence(str1, str2):\n    # your code here\n    if not str1 or not str2:\n        return False\n    else:\n        for i in range(len(str2)):\n            if str2[i] in str1:\n                str1 = str1.replace(str2[i], '', 1)\n                if not str1:\n                    return True\n        return False\n\n\n# a function with input nums that returns the maximum sum of any contiguous subarray within the array\ndef max_sum_contiguous_subarray(nums):\n    # your code here\n    if not nums:\n        return None\n    elif len(nums) == 1:\n        return nums[0]\n    else:\n        max_so_far = nums[0]\n        curr_max = nums[0]\n        for i in range(1, len(nums)):\n            curr_max = max(curr_max + nums[i], nums[i])\n            max_so_far = max(max_so_far, curr_max)\n        return max_so_far\n\n\n# a function with inputs nums and k that returns an array containing all possible combinations of k numbers out of the set of integers from 1 to n\ndef get_combinations(nums, k):\n    # your code here\n    if not nums or not k:\n        return []\n    elif len(nums) < k:\n        return []\n    else:\n        res = [[]]\n        for i in range(k):\n            new_res = []\n            for j in range(len(res)):\n                for x in range(nums[i], len(nums)+1\n\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "def substrcount(str, substr):\n    count = 0\n    for i in range(len(str) - len(substr) + 1):\n        if str[i:i+len(substr)] == substr:\n            count += 1\n    return count\n\n\n# a function with inputs str1 and str2 that returns True if str1 is a subsequence of str2\ndef is_subsequence(str1, str2):\n    # your code here\n    if not str1 or not str2:\n        return False\n    else:\n        for i in range(len(str2)):\n            if str2[i] in str1:\n                str1 = str1.replace(str2[i], '', 1)\n                if not str1:\n                    return True\n        return False\n\n\n# a function with input nums that returns the maximum sum of any contiguous subarray within the array\ndef max_sum_contiguous_subarray(nums):\n    # your code here\n    if not nums:\n        return None\n    elif len(nums) == 1:\n        return nums[0]\n    else:\n        max_so_far = nums[0]\n        curr_max = nums[0]\n        for i in range(1, len(nums)):\n            curr_max = max(curr_max + nums[i], nums[i])\n            max_so_far = max(max_so_far, curr_max)\n        return max_so_far\n\n\n# a function with inputs nums and k that returns an array containing all possible combinations of k numbers out of the set of integers from 1 to n\ndef get_combinations(nums, k):\n    # your code here\n    if not nums or not k:\n        return []\n    elif len(nums) < k:\n        return []\n    else:\n        res = [[]]\n        for i in range(k):\n            new_res = []\n            for j in range(len(res)):\n                for x in range(nums[i], len(nums)+1", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": {"error": "unexpected EOF while parsing (<string>, line 51)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": {"error": "unexpected EOF while parsing (<string>, line 51)", "exc_type": "SyntaxError"}, "status": 0}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": {"error": "unexpected EOF while parsing (<string>, line 51)", "exc_type": "SyntaxError"}, "status": 0}], "status": "FAIL", "passed": 4, "total": 7}
{"Signature": "substrcount(str, substr)", "Input": "with inputs str and substr", "Output": "counts the number of times the sub-string substr occurs in str", "Description": "Check if the model is capable of performing basic string manipulation.", "name": "StringCountTokens", "language": "javascript", "prompt": "\n// a function with inputs str and substr that returns counts the number of times the sub-string substr occurs in str\nfunction substrcount(str, substr) {", "answer": "\n\nfunction substrcount(str, substr) {\n\n    var count = 0;\n    for (var i=0; i<str.length; i++) {\n        if (str[i] === substr) {\n            count++;\n        }\n    }\n    return count;\n}\n\nconsole.log(\"The string 'hello world' has \" + substrcount('hello world', 'l') + \" l's\");\n", "params": {"do_sample": true, "temperature": 0.7, "max_length": 512, "top_k": 40, "top_p": 0.1, "repetition_penalty": 1.176}, "model": "abhinavkulkarni/Salesforce-codegen25-7b-multi-w4-g128-awq", "runtime": "awq", "code": "function substrcount(str, substr) {\n\n    var count = 0;\n    for (var i=0; i<str.length; i++) {\n        if (str[i] === substr) {\n            count++;\n        }\n    }\n    return count;\n}\n\nconsole.log(\"The string 'hello world' has \" + substrcount('hello world', 'l') + \" l's\");", "checks": [{"assert": "len(f.args)", "eq": 2, "got": 2, "status": 1}, {"assert": "f.name", "eq": "substrcount", "got": "substrcount", "status": 1}, {"assert": "f.args[0].name", "eq": "str", "got": "str", "status": 1}, {"assert": "f.args[1].name", "eq": "substr", "got": "substr", "status": 1}, {"assert": "f.call('aaa','a')", "eq": 3, "got": 3, "status": 1}, {"assert": "f.call(\"babaab\",\"ab\")", "eq": 2, "got": 0, "status": 0}, {"assert": "f.call(\"abcabcefgabc\",\"abc\")", "eq": 3, "got": 0, "status": 0}], "status": "FAIL", "passed": 5, "total": 7}